<!doctype html><html lang=zh-cn><title>我所理解的 iptables u32 匹配 - imlonghao</title><meta name=description content="昨天晚上，为了解决运营商的网络挟持问题，我苦看了很久 iptables 的文档：iptables(8) - Linux man page"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=renderer content="webkit"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><link rel=dns-prefetch href=//vip1.loli.net><link rel=stylesheet href=/static/hw3x7x.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/disqusjs@1.3.0/dist/disqusjs.css integrity="sha256-GxdCIOyfxQ1OBfS99qAIJDoGK1ADuBsxhMTqXG82fAY=" crossorigin=anonymous><script src=/static/hw3x7x.js async></script><script src=https://cdn.jsdelivr.net/npm/disqusjs@1.3.0/dist/disqus.js integrity="sha256-LVaMHPQ2zLqOc5rXSAfr4d1PIkEGNLyyUTDNPZmTtUw=" crossorigin=anonymous></script><script src=//instant.page/3.0.0 type=module defer integrity=sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1></script><link rel=alternate type=application/rss+xml title="imlonghao Feed" href=https://imlonghao.com/feed.xml><div id=container><div id=header><div id=post-nav><a href=./>Home</a>
&nbsp;»&nbsp;
<a href=./30.html>我所理解的 iptables u32 匹配</a></div></div><div class=clearfix></div><div id=title>我所理解的 iptables u32 匹配</div><div id=content class=markdown-body><p>昨天晚上，为了解决运营商的网络挟持问题，我苦看了很久 iptables 的文档：<a href=http://linux.die.net/man/8/iptables rel=nofollow>iptables(8) - Linux man page</a><p>在文档当中，其中的 <code>u32</code> 值得我们去学习。下面就来简单讲解一下这个匹配方式。<h2>u32 简介</h2><blockquote><p>U32 allows you to extract quantities of up to 4 bytes from a packet,
AND them with specified masks, shift them by specified amounts and
test whether the results are in any of a set of specified ranges.</blockquote><p>u32 允许你从一个包中提取 4 个字节，然后通过指定的掩码，偏移一定数量的单位到某个位置然后比对这个数值是否为某个值或者是否在某个区间中。<p>u32 默认是从 ip 头开始截取数据，当然，我们可以通过适当的掩码以及右移，来移动到 TCP 头又或者是 SSL 头中去，这都取决与你的选择。<h2>u32 入门</h2><p>首先，我们先来认识以下一个普通的 packet 包，下面我将用 <a href=https://www.wireshark.org/ rel=nofollow>wireshark</a> 随便抓一个包进行演示。<p><img src=https://vip1.loli.net/2019/12/26/ELWskTtVZHD17Sr.png alt="MAC 帧头">
(MAC 帧头)<p><img src=https://vip1.loli.net/2019/12/26/NuPFU2o87GHaXIg.png alt="IP 头">
(IP 头)<p><img src=https://vip1.loli.net/2019/12/26/yz5rfpstFQVHxuv.png alt="enter image description here">
(TCP 头)<p>正如我上面引入所说， u32 是从 IP 头开始取，因此我们完全可以跳过 MAC 帧头，因此里面的东西对我们实际的应用并没有什么用。我们主要关注下面的 IP 头以及 TCP 头即可。<p>为了方便大家看，我把 IP 头以及 TCP 头的东西手写出来<pre><code>45 00 00 3c 00 00 40 00 31 06 ef 34 79 29 59 34 c0 a8 c7 81
</code></pre><p>(IP 头)<pre><code>00 50 95 3c 8d 7f 52 ac 69 15 33 be a0 12 71 20 cd dc 00 00 02 04 05 14 04 02 08 0a 08 c8 62 fa 00 1c 30 a1 01 03 03 07
</code></pre><p>(TCP 头)<h3>u32 基础</h3><pre><code>iptables -m u32 --u32 &quot;Start&amp;Mask=Range&quot;
</code></pre><p>上面就是一个 u32 简单的语法，其中：<p><code>Start</code> 表示开始取值的位置 / 字节<p><code>Mask</code> 表示掩码<p><code>Range</code> 表示匹配的范围，可以是一个使用 <code>:</code> 分割开的区间，也可以只是一个数<p>如果我们需要同时检查多个规则，规则之间可以通过 <code>&&</code> 隔开<p>小技巧：通常我们可以通过(我们想要的字节的末位位置)减去 3 的方法来得到我们开始取值的位置<h3>u32 操作符</h3><p>在上面的基础中，我们已经使用到了一个操作符 <code>&</code> ，此外，总共有四个操作符可供使用。<p><code>&</code> 按位与操作符：过滤出我们需要的四个字节（最多），或者只要其中一个字节<p><code>&lt;&lt;</code> 左移操作符： 把操作数的各二进位全部左移若干位，高位丢弃，低位补 0<p><code>>></code> 右移操作符：把操作数的各二进位全部右移若干位，低位丢弃，高位补 0（或 1）<p><code>@</code> 向前推进操作符：向前推进若干的字节数<h3>取 TCP 头数据</h3><p>由于 IP 头的长度未知，一般来所是 20 个字节，但是如果有 <code>IP options</code> 的话， IP 头的长度会更长，因此我们无法直接取第 20 个字节之后的数据，来跳到 TCP 头。<p>因此这里我们需要使用到 <code>@</code> 运算符。<p>我们直接看一个例子（仅做示范）：<pre><code>0&gt;&gt;22&amp;0x3C@ 4 &amp;0xFF=0x29
</code></pre><p><code>0>>22</code> ，它的含义是取 IP 报头的第 0 偏移处的 4 字节值一共 32 位，右移 22 位得到 10 位的数值，接下来和 <code>0x3C</code> 即二进制的 <code>111100</code> 按位与，得到上述的 IP 头长度，然后使用 <code>@</code> 运算符直接推进到 TCP 头<h3>取 TCP 头之后的数据（仅做示范）</h3><pre><code>0&gt;&gt;22&amp;0x3C@12&gt;&gt;26&amp;0x3C@ 4 &amp;0xFF=0x29
</code></pre><h3>实例：判断 TTL 是否在 50 到 60 之间</h3><p>根据上文，本个 packet 的十六进制值是 31 ，位置是第 8 个字节（从 0 开始算）。<p>那么我们 <code>Start</code> 的字节就是 <code>8-3=5</code> ，我们要取的是最后的一个字节，所以掩码是 <code>0x000000FF</code> 或者使用等价的 <code>0xFF</code><p>那么我们的代码就是 <code>5&0xFF=0x32:0x3C</code><h3>实例：检查目标 IP 是否为 121.41.89.52</h3><p>我们先将 IP 地址 <code>121.41.89.52</code> 转换为数字地址 <code>2032752948</code><p>然后将数字地址 <code>2032752948</code> 通过十进制转十六进制转换成 <code>79 29 59 34</code><p>观察可知， <code>34</code> 是 IP 头中的第 16 个字节，那么 <code>Start</code> 的位置就是 <code>16-3=13</code><p>由于我们现在需要的是整个取出来的 4 个字节，因此我们的掩码为 <code>0xFFFFFFFF</code> 或者不填<p>因此，我们的代码是 <code>13=0x79295934</code><h3>实例：检查目标端口是否为 38204</h3><p>同样，将 <code>38204</code> 转换成十六进制，那就是 <code>953c</code><p>目标端口在 TCP 头中，观察，可以 <code>3c</code> 在 TCP 头中的第 3 个字节，因此， <code>Start</code> 的位置是 <code>3-3=0</code><p>结合上面跳到 TCP 头的代码，现在我们的代码是<pre><code>0&gt;&gt;22&amp;0x3C@0&amp;0xFFFF=0x953C
</code></pre><h3>实例：检查 UDP 有效负荷的值</h3><p>等于号后面的值其实不用十六进制也可以，直接使用十进制。<pre><code>6&amp;0xFF=17 &amp;&amp; 4&amp;0x1FFF=0 &amp;&amp; 0&gt;&gt;22&amp;0x3C@0&amp;0xFFFF=53 &amp;&amp; 0&gt;&gt;22&amp;0x3C@8&gt;&gt;15&amp;0x01=1
</code></pre><p><code>6&0xFF=17</code> 判断这个是否是一个 UDP 包<p><code>4&0x1FFF=0</code> 判断这个包是否是第一个分片<p><code>0>>22&0x3C@0&0xFFFF=53</code> 判断目标端口是否为 <code>53</code><p><code>0>>22&0x3C@8>>15&0x01=1</code> 为了得到字节 2 的高位，用偏移量 8 来获取头 4 个字节的有效负荷，并且右移 15 位，把 Query 位放到最低位置，再弃去其它的位，然后使用掩码 <code>0×01</code><h2>参考资料</h2><p><a href=http://www.stearns.org/doc/iptables-u32.current.html rel=nofollow>IPTables U32 Match Tutorial</a><p><a href=http://blog.chinaunix.net/uid-12798245-id-114886.html rel=nofollow>IPTables U32 匹配指南（上一个链接的中文版）</a><p><a href=https://blog.g3rt.nl/take-down-sslv3-using-iptables.html rel=nofollow>How to take down SSLv3 in your network using iptables firewall? (POODLE)</a><h2>写在最后</h2><p>由于本人学习 u32 的时间不长，上面的也是我凭感觉写出来的，如果有纰漏的地方，敬请指出！</div></div><div id=disqus_thread></div><div id=footer><span>Copyright © 2015 - 2020 imlonghao. Theme by
<a href=http://simiki.org/ target=_blank rel="noopener noreferrer">Simiki</a>. CC BY-NC-SA 4.0</span></div><script src=https://cdn.jsdelivr.net/npm/cfga@1.0.3/cfga.min.js integrity="sha256-TXHTTKAPRQ9mgacgN+couk0xnzQ6uOXTZ5ojH1q6GUk=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/vanilla-lazyload@12.3.0/dist/lazyload.min.js integrity="sha256-bojBIKfs4l2WDcJODncBIGEe5fhU7/sM3zRO5/f2nqE=" crossorigin=anonymous async></script>